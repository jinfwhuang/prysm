syntax = "proto3";

package ethereum.eth.v1alpha1;

import "proto/eth/ext/options.proto";
import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

import "proto/prysm/v1alpha1/attestation.proto";
import "proto/prysm/v1alpha1/beacon_state.proto";
import "proto/prysm/v1alpha1/beacon_block.proto";
import "proto/prysm/v1alpha1/sync_committee.proto";

option csharp_namespace = "Ethereum.Eth.V1alpha1";
option go_package = "github.com/prysmaticlabs/prysm/proto/prysm/v1alpha1;eth";
option java_multiple_files = true;
option java_outer_classname = "LightClient";
option java_package = "org.ethereum.eth.v1alpha1";
option php_namespace = "Ethereum\\Eth\\v1alpha1";




//message UpdatesRequest {
//  repeated uint64 sync_committee_periods = 1;
//}



/**
class BeaconBlockHeader(Container):
    slot: Slot
    proposer_index: ValidatorIndex
    parent_root: Root
    state_root: Root
    body_root: Root

class BeaconBlockBody(Container):
    randao_reveal: BLSSignature
    eth1_data: Eth1Data  # Eth1 data vote
    graffiti: Bytes32  # Arbitrary data
    # Operations
    proposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]
    attester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]
    attestations: List[Attestation, MAX_ATTESTATIONS]
    deposits: List[Deposit, MAX_DEPOSITS]
    voluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]
    sync_aggregate: SyncAggregate  # [New in Altair]

class LightClientUpdate(Container):
    # Update beacon block header
    header: BeaconBlockHeader
    # Next sync committee corresponding to the header
    next_sync_committee: SyncCommittee
    next_sync_committee_branch: Vector[Bytes32, floorlog2(NEXT_SYNC_COMMITTEE_INDEX)]
    # Finality proof for the update header
    finality_header: BeaconBlockHeader
    finality_branch: Vector[Bytes32, floorlog2(FINALIZED_ROOT_INDEX)]
    # Sync committee aggregate signature
    sync_committee_bits: Bitvector[SYNC_COMMITTEE_SIZE]
    sync_committee_signature: BLSSignature
    # Fork version for the aggregate signature
    fork_version: Version

class SkipSyncUpdateKey(Container):
    epoch: Epoch
    sync_committee: SyncCommittee

def get_skipsync_content_key(epoch: Epoch, next_sync_committee SyncCommittee) -> bytes:
    """
    epoch: Refers to the epoch of the current head; deduce from header.Slot
    sync_committee: The next_sync_committee associated with the current head
    """
    key = SkipSyncUpdateKey()
    key.epoch = epoch
    key.next_sync_committee = next_sync_committee

    return serialize(SkipSyncUpdateKey, key)

GET /eth/light-client/v1/skip-sync-update?key=<content-key>
GET /eth/light-client/v1/updates

 */
//    type Store struct {
//Snapshot     *ethpb.ClientSnapshot
//    ValidUpdates []*ethpb.LightClientUpdate
//    }

message LightClientStore {
  ethereum.eth.v1alpha1.LightClientSnapshot store = 1;
  repeated ethereum.eth.v1alpha1.LightClientUpdate updates = 2;
}

message LightClientSnapshot {
  ethereum.eth.v1alpha1.BeaconBlockHeader header = 1;
  ethereum.eth.v1alpha1.SyncCommittee current_sync_committee = 2;
  ethereum.eth.v1alpha1.SyncCommittee next_sync_committee = 3;
}

message LightClientUpdate {
  ethereum.eth.v1alpha1.BeaconBlockHeader header = 1;

  // Next sync committee corresponding to the header
  ethereum.eth.v1alpha1.SyncCommittee next_sync_committee = 2;
  repeated bytes next_sync_committee_branch = 3 [(ethereum.eth.ext.ssz_size) = "5,32"];

  // Finality proof for the update header
  ethereum.eth.v1alpha1.BeaconBlockHeader finality_header = 4;
  repeated bytes finality_branch = 5 [(ethereum.eth.ext.ssz_size) = "6,32"];

  // Sync committee aggregate signature
  bytes sync_committee_bits = 6 [(ethereum.eth.ext.ssz_size) = "sync_committee_bytes.size", (ethereum.eth.ext.cast_type) = "sync_committee_bits.type"];
  bytes sync_committee_signature = 7 [(ethereum.eth.ext.ssz_size) = "96"];

  // Fork version for the aggregate signature
  bytes fork_version = 8 [(ethereum.eth.ext.ssz_size) = "4"];
}

message SkipSyncUpdate {
  ethereum.eth.v1alpha1.BeaconBlockHeader header = 1;

  // Current sync committee corresponding to the header
  ethereum.eth.v1alpha1.SyncCommittee current_sync_committee = 2;
  repeated bytes current_sync_committee_branch = 3 [(ethereum.eth.ext.ssz_size) = "5,32"];

  // Next sync committee corresponding to the header
  ethereum.eth.v1alpha1.SyncCommittee next_sync_committee = 4;
  repeated bytes next_sync_committee_branch = 5 [(ethereum.eth.ext.ssz_size) = "5,32"];

  // The block header corresponding to finality checkpoint root
  ethereum.eth.v1alpha1.BeaconBlockHeader finality_header = 6;
  repeated bytes finality_branch = 7 [(ethereum.eth.ext.ssz_size) = "6,32"];

  // Sync committee aggregate signature
  bytes sync_committee_bits = 8 [(ethereum.eth.ext.ssz_size) = "sync_committee_bytes.size", (ethereum.eth.ext.cast_type) = "sync_committee_bits.type"];
  bytes sync_committee_signature = 9 [(ethereum.eth.ext.ssz_size) = "96"];

  // Fork version for the aggregate signature
  bytes fork_version = 10 [(ethereum.eth.ext.ssz_size) = "4"];
}

// Services
service LightClient {
  rpc GetUpdates(google.protobuf.Empty) returns (UpdatesResponse) {
    option (google.api.http) = {
      get: "/eth/v1alpha1/light-client/updates",
    };
  }
  rpc GetSkipSyncUpdate(SkipSyncRequest) returns (SkipSyncUpdate) {
    option (google.api.http) = {
      get: "/eth/v1alpha1/light-client/skip-sync",
    };
  }
  rpc DebugGetTrustedCurrentCommitteeRoot(google.protobuf.Empty) returns (DebugGetTrustedCurrentCommitteeRootResp) {
    option (google.api.http) = {
      get: "/eth/v1alpha1/light-client/debug-get-trusted-sync-comm-root",
    };
  }
}

message UpdatesResponse {
  repeated LightClientUpdate updates = 1;
}

message SkipSyncRequest {
  // Merkle root of a SyncCommittee, the current sync committee
  bytes key = 1 [(ethereum.eth.ext.ssz_size) = "32"];
}

message DebugGetTrustedCurrentCommitteeRootResp {
  // Merkle root of a SyncCommittee, the current sync committee
  bytes key = 1 [(ethereum.eth.ext.ssz_size) = "32"];
}


//message UpdateResponse {
//  repeated LightClientUpdate updates = 1;
//}


//message SkipSyncResponse {
//  SkipSyncUpdate update = 1;
//}

//message SkipSyncRequestKey {
//  uint64 epoch = 1 [(ethereum.eth.ext.cast_type) = "github.com/prysmaticlabs/eth2-types.Epoch"];
//  ethereum.eth.v1alpha1.SyncCommittee next_sync_committee = 2;
//}



// Light Client Node
service LightNode {
  // Beacon state API related endpoints.

//  // GetGenesis retrieves details of the chain's genesis which can be used to identify chain.
//  rpc GetGenesis(google.protobuf.Empty) returns (v1.GenesisResponse) {
//    option (google.api.http) = { get: "/internal/eth/v1/beacon/genesis" };
//  }

  // ListBlockHeaders retrieves block headers matching given query. By default it will fetch current head slot blocks.
  rpc Head(google.protobuf.Empty) returns (BeaconBlockHeader) {
    option (google.api.http) = {
      get: "/internal/eth/v1/beacon/head"
    };
  }

  rpc FinalizedHead(google.protobuf.Empty) returns (BeaconBlockHeader) {
    option (google.api.http) = {
      get: "/internal/eth/v1/beacon/finalized-head"
    };
  }
}
